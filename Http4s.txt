

The http4s library is based on the concepts of Request and Response. Indeed, we respond to a Request through a set of functions of type Request => Response. We call these functions routes, and a server is nothing more than a set of routes.

we aim to maintain the referential transparency of our functions. Hence, the library surrounds the Response type into an effect F[_]. So, we change the previous route definition in Request => F[Response].

Nevertheless, not all the Request will find a route to a Response. So, we need to take into consideration this fact, defining a route as a function of type Request => F[Option[Response]]. Using a monad transformer, we can translate this type in Request => OptionT[F, Response].

Finally, using the types Cats provides us, we can rewrite the type Request => OptionT[F, Response]using the Kleisli monad transformer. Remembering that the type Kleisli[F[_], A, B] is just a wrapper around the function A => F[B], our route definition becomes Kleisli[OptionT[F, *], Request, Response].

Fortunately, the http4s library defines a type alias for the Kleisli monad transformer that is easier to understand for human beings: HttpRoutes[F].

We must remember that we are using a library that is intended to embrace the purely functional programming paradigm. Hence, our code must adhere to the substitution model, and we know for sure that every code producing any possible side effect is not compliant with such a model. 

So, the functional programming paradigm overcomes this problem using the Effect Pattern. Instead of executing directly the code that may produce any side effect, we can enclose it in a particular context that describes the possible side effect but doesn’t effectively execute it, together with the type the effect will produce:
```
val hw: IO[Unit] = IO(println("Hello world!"))
```

A Semigroup is a type class granting the capability of a type to combine two values of that type and produce another value of that same type:
```
trait Semigroup[A] {
  def combine(x: A, y: A): A
}
```
We can use Semigroups whenever we write generic code and operate with values that need to be combined:
	numbers
	strings
	shopping carts in an online store
	permissions in a data repository


Monoids are a special kind of semigroups, where besides the combination function, we also have a “neutral element” of that combination function. We call that value empty, or “zero” (with the proper quotes because zero has a special meaning in math, you know). The property is that
```
combine(x, empty) == x
combine(empty, x) == x

// for all elements x of type A. A monoid is defined as

trait Monoid[A] extends Semigroup[A] {
  def empty: A
}
```


Functors describe the capability to “map” containers, such as lists, options, sets, futures, etc. The functor trait looks like this:
```
trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A => B): F[B]
}
```


Monads are the sweet spot of pure FP. They encapsulate chainable computations
Monads have two capabilities:
- the capability to “lift” a plain value into a monadic type, an operation known as pure
- the capability to “chain” computations of monadic types, an operation known as flatMap or bind
```
trait Monad[F[_]] {
  def pure[A](a: A): F[A]
  def flatMap[A, B](fa: F[A])(f: A => F[B]): F[B]
}
```


The main intuition of monads is the “chained” computations of FP. Therefore, the pure method should be the one to go into a separate type class. That type class is called Applicative, and it sits between Functor and Monad.
```
trait Applicative[F[_]] extends Functor[F] {
  def pure[A](a: A): F[A]
}
```
Applicative is the type class with the capability to wrap a plain value into a wrapped type.


```
trait FlatMap[F[_]] extends Functor[F] {
  def flatMap[A, B](fa: F[A])(f: A => F[B]): F[B]
}
```
Monad extends these two and implements that map method for free:
```
trait Monad[F[_]] extends FlatMap[F] with Applicative[F] {
  override def map[A, B](fa: F[A])(f: A => B) = {
    flatMap(fa)(a => pure(f(a)))
  }
}
```

                     Functor
  Semigroup               │
      │           ┌───────┴────────┐
      │           │                │
      ▼           ▼                ▼
   Monoid     FlatMap           Applicative
                  │                │
                  └───────┬────────┘
                          │
                          ▼
                        Monad


Whenever we write a for-comprehension of two lists (or a flatMap), we’re doing a cartesian product of those two lists. The concept of a cartesian product (which is not the same as a flatMap) is core to the type class called Semigroupal.
```
trait Semigroupal[F[_]] {
  def product[A, B](fa: F[A], fb: F[B]): F[(A, B)]
}
```

The mapN method not only does a (cartesian) product between two wrapped values, but it also applies a function to the elements being tupled. 
```
def mapN[A, B, C](fa: F[A], fb: F[B])(f: (A, B) => C): F[C] = {
  map(product(fa, fb)) {
    case (a, b) => f(a, b)
  }
}
```

                      Functor            Semigroupal
                         │                    │
                 ┌───────┴────────┐ ┌─────────┘
 Semigroup       │                ▼ ▼
     │           │               Apply
     │           │                 │
     ▼           ▼                 │
  Monoid     FlatMap               ▼
                 │             Applicative
                 │                 │
                 └───────┬─────────┘
                         │
                         ▼
                       Monad


Besides Applicatives which can wrap successful values of type A into a wrapped type F[A], we can also wrap error types and treat them in the same way:
```
trait ApplicativeError[F[_], E] extends Applicative[F] {
  def raiseError[A](error: E): F[A]
}

// We have an error-enhanced monadic type:
trait MonadError[F[_], E] extends ApplicativeError[F, E] with Monad[F]
``
                      Functor            Semigroupal
                         │                    │
                 ┌───────┴────────┐ ┌─────────┘
 Semigroup       │                ▼ ▼
     │           │               Apply
     ▼           ▼                 │
  Monoid     FlatMap               ▼
                 │             Applicative
                 │                 │
                 └───────┬─────────┤
                         ▼         │
                       Monad       │
                         │         ▼
                         │    ApplicativeError
                         │         │
                         └─────┬───┘
                               │
                               ▼
                          MonadError

